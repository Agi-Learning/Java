# Microservices Architecture Spring Boot

* You guys hear the term called Microservices before, as it got media attractions during last few year. And even nowadays, maximum industry before 2 is this microservices architecture as part of their project in real time. So let us understand it step by step what exactly the microservices and why we need. So let me keep the overview what exactly we are going to discuss here. This is what the agenda we are going to learn. But

## Agenda

1. What is microservices?
2. Why microservices?
3. What is monolithic architecture?
4. Drawbacks of monolithic architecture?
5. Advantages to use micro service?

### What is Microservice

* So we should explain what is microservices. I want to convince one thing guys here. So the first thing is microservices She is not any kind of Technology. It is just an architectural way to design our application to maintain loosely coupled from 1 module to another module. So lets understand it. Microsurvices, architectural way to design our application uniquely with several small margins where we can develop package and deployed our application individual. And the entire process is the individual process. So there is no tightly coupled between multiple modules. That is what the advantages of microservices. So we will understand in more depth about the microservices once I cover all the slide with architecture.

### Why Microservice

* So why Microservices came into picture where previously we were developing and deploying our application in monolithic approach. So it means, before Micro Services industry was following the monolithic approach. So what exactly this monolithic approach? Let us understand it. So now let's understand what is monolithic architecture and what was the problem there in monolithic architecture, so that people are going forward to use microservice

### Monolithic Architecture

* The architecture of Monolithic. So in monolithic approach, what we are doing normally, we are developing our every service individually and at end of developing air packaging all service as a single wire file. And then at end we are deploying it in server. So that is what I mention in this architecture. So if you observe here, passenger management is one service building, notification. Each are 1 on service here. And we are developing each service individually at. then at end all the service we are packaging in a single wire. Then we are deploying it to the server. So here you should think, what is the problem in this monolithic architecture? Where, as usual, we are developing a service. And at end we are packaging them as a single 1. S Now lets come to the point. What are the disadvantages of this approach? The

#### Drawback Of Monolithic Architecture

* Performance Issue due to this huge data.
* Continuous deployment not possible.
* Adopting new technologies will be Difficult.
* Overloaded IDE and overloaded group container
* Exception Propagation not proper
* Code readable is not there

* lets understand what exactly this performance issue in our monolithic architecture. Let me show you the diagram. Ok, so, as I told after development, all we are deploying as a single wire, right? So the performance become slow because huge data present in that war. And once the application itself becomes big, S quick development and delivery become too much difficult, isn't it If I do here passenger management building notification and all the services, if I will buy to a single wire, then all the modules, class, object, what we did in the code will be part of the single wire and that war size will be more huge. So that is what the 1st 1 is while deploying and while developing also. It is not giving us the good performance. Now move to the next disadvantages. The next
* continuous deployment, not possible. So what? That was the problem in continuous deployment. So let's understand it. So assume As it is the monadic architecture, we need to deploy single wire by binding all the services. Assume there is some bug or defect in passenger management. And I open that passenger management code, and I get the changes. So as it is monolithic, I can deploy this passenger management as a single wire in my servo. Again, I need to repackage all the services, even though there is no issue in building notification, three management driver management. Only issue is in passenger management. I did the. I did the code fix, but again, I need to repackage all the surfaces. So that is what the continuous deployment issue in our monolithic architecture, even though we are going to change in a single service or single life, then again, you need to redeploy your entire code base Come to the next point
* Adopting new Technology will be difficult so let's. so let's understand what will be the cost or what will be the problem if I am going to add a new technology in between one motive So here assume I have a passenger management yielding notification. Suppose all the services I used Java code in notification service. I want to use some python or some other technology but ultimately at end we are going to package all as a wire and we are going to deploy in a server. So if I will change the technology of a specific module, it would not allow me to. or we can say it is not kind of compatible with other motive. So this is what the 1 kind of biggest problem in our monolithic architecture technology we cannot choose for all the services we need to choose same kind of technology. If we are developing all in Java then all we need to do with Java code only suppose notification or payment single or module I can change with any other technology come to the next point.
* Overloaded IDE and overloaded group container -> So, as I told everything, we are packaging in a single wire. So there the container will also able to take the load of that work. So there is no more productivity in this case. So the next 1 is
* exception propagation, not proper So what exactly this exception propagation is not proper in monolithic architecture Suppose Ajum in my driver management. I'm getting some exception, some so in that case, it will impact on all the services, because driver management internally use the notification for email notification or message notification, or it directly connect to the payment through rest call. So one service is getting failed here, then it will impact on other services. So there is no proper exception, propagation management kind of thing in monolithic architecture. Then move to the next point.
* Code readable is not there. Suhart exactly this code redeem guys like Azure. One new resource join in our project. And he got some tasks. So how we can analyze, to analyze it first, he need to understand complete flow to Nado, exact business of a specific module. So let me show you that surface. 1 new developer joined in my team, and there is some issue in payment services or billing services. I assign a task to that guy, that user I assign to are from billing services, but to understand what exactly these billing service is doing. So he need to go through the entire code base. He need to understand what this passenger management is doing, what trifle management, treat management. So he need to understand entire flow. Then only he can identify the Root Causeway where exactly he need to do the changes. Ok, so these are what the problem we faced in monolithic architecture. So let us replace once again. The 1st one is.

### Microservice Architecture

* So if you can observe your passenger management. Management at three management. Each are different service and have their own database, different database for treatment. I am using treat database for driver management. I am eating driver management database for passenger management. I am using passenger management data. So this is what the typical micro service architecture. Now let us compare the disadvantages of monolithic architecture, and then how we resolved in this micro service architecture.
* So in monolithic, the 1st one is. Perfumancy suit due to his data or Is everything we are packaging in a single war. So in case of microservices, each have their own dependent like passenger management of their own deployment, driver management of their own deployment. Means the deployment of each module will be independent, and deployment also independent. Like we no need to combine all these three modules, single door. I can develop passenger management, and I can deploy it as a single wire. Similarly, for driver management also for tree management also. Each module, we can deployed as a single wire instead of combining them in a single wire. To the first one performance issue due to huge data. Assume I download the development for passenger management, and I'm going to deploy that particular passenger management microphone before. So in that case, only the code or the classes or the library, what are there in passenger management? I am going to deploy as a single bar S. The load for that particular passenger management warrant will not be moved. The data is not huge. Similarly, same for driver management. So there is no performance issue like as we are deploying each. microservice as an individual war So the next problem was in monolithic. There is a problem in continuous deployment.
* So if you come to the microservices, suppose there is a burger defect in driver management, then directly I need to go to this driver management code base and I will check. I will analyze what is the root causeway and I can fix it and then instead of redeploy all the modules single package I can only redeploy the driver management. I do not need to touch the code of passenger management or pre management. So the continuous deployment will be more easy in case of Microsoft. So there is no dependent. for driver management with other micro services wherever you are doing the change you can deploy or we can package particular that module Ok, so this is how the continuous deployment will be more rigid in case of microservices. And the 3rd one is
* Adopting technology so as. each are their different module and deployed as a single war. Suppose I want to develop this driver management as in Python so I can write the code in Python. I can connect the way Python is connecting to the database. I can do the same way and at end I can like if I want to communicate with passenger management from driver management, I can do the rest call to that particular passenger management or treat management like that. We can add up technology. whenever you want. Like As I told, Microsoft can content multiple model, so wherever if I am suitable technology which can give you the better performance, you can easily change that And the next problem was in monolithic. That is the exception propagation
* So if you come to the microservice architecture, suppose my treat management service is getting failed. And from driver management, I am invoking the treat management. Then that time I can add one additional layer or we can say in microservices they provided on component. That is the named histories. Using hysterics, that is kind of circuit breaker design pattern. Or we can say, fault tolerance tool. So using hysteresis that we can propagate to the other services. So that is what the advantages of microarchitecture to handle now, or to propagate the exception The last drawback is in architecture.
* Is the code redeemable? Is very difficult in monolithic, where, in case of microservices, one new resource joined in our team. And I ask Send task into work on a treat management. Then I can, as I told each business, we are creating a different model. So you can directly come to the trade management and he can fix the defect and he can redeploy it. So that is what will be more easy known to go through the entire code. Her driver management is doing what passenger management is doing. So he got a task in this particular model. He can go to that. He can debug, and he can easily fix it. So that is what the code readable is more easy in case of Micro Service architecture. So what are the drawback we discussed in monolithic architecture that we can easily reserved in Microsoft? That is what I explained in this current slide. So let's. go through a typical microservice architecture once again

### Typical MA

* So this is what the typical microservice architecture so. this is the client will send a request and it will goes to the api gateway. So api gateway for this microservice architecture. If you are going to the Java spring provided springboard provided one that is the gateway who will helps us to redirect the url. Suppose URL is coming for passenger management. It will redirect to the passenger management based on incoming url which we configured on this api gateway based on that url it will propagate the request to the corresponding microservice. So once request will come to the passenger management. So if passenger management talk to the payment, he can do the rest call. Similarly, you can see all the Microsoft. is individually developed here and whoever want to communicate with each other, they are invoking with rest api call. You can observe treat management billing similarly driver management notification there communicating via rest api call and for passenger management he have their own independent database for building. We have billing database like this. For specific to a module. All the required software, all the required dependency, will be separate for a particular module Ok. And if I did the 4th change in a specific model, I can only need to redeploy that particular module. Suppose in payments, I need to deploy on that payment only. I don't need to bother about the billing, as already billing passenger driver, all the model up and running. So this is hard, the typical architecture of microservices. So this is the comparison between monolithic architecture and microservice architecture.

### Mono vs MA

* As I as you discussed in Monmouthic Architecture, request will be come from ui, then business logic in business logic. We have all the module, all the module data will be bind to a specific one. And even they are using the common database for all the motors. This is where the monolithic architecture and there are lot of problem which we discussed already.
* And that is what we overcome using the microservice architecture. So request will come to the each microservices and each microservices have their own database instance So this is all about Microservice and its architecture. Now you might have questioned how we can achieve this microservice architecture. Means which technology we need to use. So as far I know, spring would provide complete support for this micro service architecture. That's a springboard provide few component like histories, eureka service registry, api get to a tool, all those things omitted by spring book, ok, And even I uploaded all the component video in my youtube channel. Let me show you that.
